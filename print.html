<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Guía de Programacion Competitiva</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> Prefacio</a></li><li class="chapter-item expanded "><a href="introduction_1.html"><strong aria-hidden="true">2.</strong> Introducción</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2/2.1.html"><strong aria-hidden="true">2.1.</strong> Lenguajes de programación</a></li><li class="chapter-item expanded "><a href="2/2.2.html"><strong aria-hidden="true">2.2.</strong> Entrada y salida</a></li><li class="chapter-item expanded "><a href="2/2.3.html"><strong aria-hidden="true">2.3.</strong> Números y cómo representarlos</a></li><li class="chapter-item expanded "><a href="2/2.4.html"><strong aria-hidden="true">2.4.</strong> Template de C++</a></li><li class="chapter-item expanded "><a href="2/2.5.html"><strong aria-hidden="true">2.5.</strong> Cómo Practicar</a></li><li class="chapter-item expanded "><a href="2/2.6.html"><strong aria-hidden="true">2.6.</strong> Problemas Introductorios</a></li></ol></li><li class="chapter-item expanded "><a href="3/Introduccion.html"><strong aria-hidden="true">3.</strong> Matemáticas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3/divisibilidad.html"><strong aria-hidden="true">3.1.</strong> Divisibilidad</a></li><li class="chapter-item expanded "><a href="3/modular.html"><strong aria-hidden="true">3.2.</strong> Aritmética Modular</a></li><li class="chapter-item expanded "><a href="3/combi.html"><strong aria-hidden="true">3.3.</strong> Combinatoria</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Guía de Programacion Competitiva</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="prefacio"><a class="header" href="#prefacio">Prefacio</a></h1>
<p>El propósito de esta guía es dar una idea general sobre qué es la programación competitiva, tanto como incentivar a los estudiantes de grado de la Universidad de San Andrés a participar. De ninguna manera es completo, ya que hay una infinidad de temas que podrían aparecer en una competencia. Sin embargo, buscamos dar una visión general de los temas más importantes, junto con soluciones a problemas clásicos y otros misceláneos. Casi todos los problemas los tomamos de <a href="https://cses.fi/">CSES</a>, y recomendamos encarecidamente que el lector implemente todas las soluciones que comprenda.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-introducción"><a class="header" href="#1-introducción">1 Introducción</a></h1>
<p>La programación competitiva es una disciplina que se ocupa de la creación e implementación de algoritmos bajo una limitación de tiempo. Por lo general, a los concursantes se les presenta un conjunto común de problemas, que pueden tener distintos puntajes; el ganador es el concursante o equipo con mayor cantidad de puntos y menor penalidad, que suele estar dada por una combinación entre tiempo de resolución y envíos incorrectos.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lenguajes-de-programación"><a class="header" href="#lenguajes-de-programación">Lenguajes de programación</a></h1>
<p>Los lenguajes de programación permitidos varían de una competencia a otra, permitiendo en algunos casos el uso de lenguajes no estándar como Kotlin o Haskell. Sin embargo, en su mayor parte, se permiten C++, Python y Java. Esta guía está en C++ y esperamos que el lector esté familiarizado con C. De todas formas, exceptuando las líneas de código, los temas están dados de forma genérica.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrada-y-salida"><a class="header" href="#entrada-y-salida">Entrada y salida</a></h1>
<p>Dijimos que la programación competitiva se ocupa de la <em>creación e implementación de algoritmos</em>, de todas formas, no especificamos cómo sucede esto en la competencia. Normalmente, la interacción ocurre mediante la salida estándar y entrada estándar. Es decir, nos dan un <em>input</em> por la entrada estándar y debemos responder con el <em>output</em> correcto.</p>
<p>En C++, esto es <strong>cin</strong> para entrada y <strong>cout</strong> para salida.</p>
<p>Como ejemplo veremos la solución para <a href="https://codeforces.com/problemset/problem/1772/A">este</a> problema:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main()
{
    int t;
    cin &gt;&gt; t; // entrada (cantidad de casos)
    while (t--)
    {
        string op;
        cin &gt;&gt; op; // entrada (el string de cada caso)
        cout &lt;&lt; (op[0] - '0') + (op[2] - '0') &lt;&lt; "\n"; // salida (respuesta del caso)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="números-y-cómo-representarlos"><a class="header" href="#números-y-cómo-representarlos">Números y cómo representarlos</a></h1>
<p>Tipos de números frecuentes en programación competitiva:</p>
<ul>
<li><strong>int</strong> - representa números enteros y existe entre [\(-2^{31}\), \(2^{31} - 1\)], suele ser usado en la mayoría de los contextos.</li>
<li><strong>long double</strong> - se usa en entornos donde queremos representar un número que no es entero. Esto es común en problemas de geometría o de simulación de un proceso físico, por ejemplo. Este número no es exacto y puede tener errores de precisión. Por lo general, en problemas donde se necesita una representación no entera, los enunciados piden que se genere la respuesta sujeta a una precisión fija (un número típico es \(10^{-6}\)). Una forma común de lidiar con esto es haciendo:</li>
</ul>
<pre><code class="language-cpp">    long double number = 0.12312;
    int digits = 6; // for 1e-6
    cout &lt;&lt; fixed &lt;&lt; setprecision(digits) &lt;&lt; number;
</code></pre>
<ul>
<li><strong>long long int</strong> - este es un número entero pero con el doble de bits. Se usa cuando un <strong>int</strong> no es suficiente. En nuestra opinión, este es el tipo de datos más útil y normalmente se usa de forma predeterminada, en lugar de <strong>int</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-de-c"><a class="header" href="#template-de-c">Template de C++</a></h1>
<p>Un aspecto clave de la programación competitiva es el tiempo: si tenés una solución correcta para un problema, pero te llevaría horas implementarla, entonces estás perdiendo tiempo que podrías usar para pensar en otros problemas. Compartimos un posible template, comentado con explicaciones.</p>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<pre><code class="language-cpp">#define forn(i, n) for (tint i = 0; i &lt; tint(n); i++)
#define forsn(i, s, n) for (tint i = s; i &lt; tint(n); i++)
#define dforn(i, n) for (tint i = tint(n) - 1; i &gt;= 0; i--)
#define dforsn(i, s, n) for (tint i = tint(n) - 1; i &gt;= s; i--)
#define sz(x) tint(x.size())
#define all(x) x.begin(), x.end()
#define DBG(x) cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl
</code></pre>
<ul>
<li><strong>forn(i, n)</strong> - es un <strong>for</strong> que recorre los números desde el 0 hasta el n-1. La i es un <em>placeholder</em> para la variable de iteración.</li>
<li><strong>forsn(i, s, n)</strong> - es similar a lo anterior, solo que, en vez de arrancar en 0, arranca en s.</li>
<li><strong>dforn(i, n)</strong> - mismo rango que <strong>forn</strong> solo que recorre el <strong>for</strong> en el orden opuesto.</li>
<li><strong>dforsn(i, s, n)</strong> - mismo rango que <strong>forsn</strong> pero recorre en orden opuesto.</li>
<li><strong>sz(x)</strong> - consigue el tamaño de la variable y castea a <strong>tint</strong> (se explica más adelante).</li>
<li><strong>all(x)</strong> - representa los iteradores de inicio y final de una variable, lo que permite ordenar un vector de la siguiente forma <strong>sort(all(vector))</strong>.</li>
<li><strong>DBG(x)</strong> - imprime en la consola de error el nombre de la variable y al lado su valor. Es especialmente útil para debuggear.</li>
</ul>
<h2 id="otras-abreviaciones"><a class="header" href="#otras-abreviaciones">Otras abreviaciones</a></h2>
<pre><code class="language-cpp">using namespace std;
using tint = long long;
using vi = vector&lt;tint&gt;;
using pii = pair&lt;tint, tint&gt;;
</code></pre>
<ul>
<li><strong>using namespace std</strong> - se usa para no tener que andar escribiendo <strong>std:cout</strong>, <strong>std:cin</strong>, etc. Es una mala practica, pero como estamos en programación competitiva eso no nos importa.</li>
<li><strong>tint</strong> - define el <em>type of int</em>, o tipo de número que vamos a utilizar en el problema. Esto es para evitar cometer errores de tipo y acostumbrarse a escribir <strong>tint</strong>, en vez de tener que pensar cada vez que escribimos una variable.</li>
<li><strong>vi</strong> - vector de <strong>tints</strong>.</li>
<li><strong>pii</strong> - par de <strong>tints</strong>.</li>
</ul>
<h2 id="optimización-de-inputoutput"><a class="header" href="#optimización-de-inputoutput">Optimización de Input/Output</a></h2>
<pre><code class="language-cpp">inline void fastIO()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
}
</code></pre>
<p>Esta función suele ser llamada en la primera línea del <strong>main</strong> en C++, se encarga de optimizar <strong>std::cin</strong> y <strong>std::cout</strong>, que por default son lentos.</p>
<h2 id="chmax-y-chmin"><a class="header" href="#chmax-y-chmin">chmax y chmin</a></h2>
<p>La idea de <strong>chmax</strong> y <strong>chmin</strong> es generalizar funciones nativas del lenguaje como <strong>+=, &amp;= o |=</strong>. <strong>chmax(variable, valor)</strong> actualiza a la variable de esta forma: variable = <strong>max(variable, valor)</strong>. <strong>chmin</strong> hace lo mismo pero con el mínimo.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
inline void chmax(T &amp;lhs, T rhs)
{
    lhs = max(lhs, rhs);
}

template &lt;typename T&gt;
inline void chmin(T &amp;lhs, T rhs)
{
    lhs = min(lhs, rhs);
}
</code></pre>
<h2 id="funciones-para-debuggear"><a class="header" href="#funciones-para-debuggear">Funciones para debuggear</a></h2>
<pre><code class="language-cpp">// printea pairs, sirve para debuggear
template &lt;typename T, typename U&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const pair&lt;T, U&gt; &amp;p)
{
    os &lt;&lt; "(" &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ")";
    return os;
}

// printea vectores, sirve para debuggear
template &lt;typename T&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;v)
{
    os &lt;&lt; "[";
    forn(i, sz(v))
    {
        if (i &gt; 0)
            os &lt;&lt; ", ";
        os &lt;&lt; v[i];
    }
    os &lt;&lt; "]";
    return os;
}
</code></pre>
<h2 id="template-completa"><a class="header" href="#template-completa">Template completa</a></h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define forn(i, n) for (tint i = 0; i &lt; tint(n); i++)
#define forsn(i, s, n) for (tint i = s; i &lt; tint(n); i++)
#define dforn(i, n) for (tint i = tint(n) - 1; i &gt;= 0; i--)
#define dforsn(i, s, n) for (tint i = tint(n) - 1; i &gt;= s; i--)
#define sz(x) tint(x.size())
#define all(x) x.begin(), x.end()
#define DBG(x) cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl

using namespace std;

using tint = long long;
using vi = vector&lt;tint&gt;;
using pii = pair&lt;tint, tint&gt;;

inline void fastIO() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
}

inline string YN(bool x, string y = "YES", string n = "NO") { return (x ? y : n); }

template &lt;typename T&gt;
inline void chmax(T &amp;lhs, T rhs) {
  lhs = max(lhs, rhs);
}

template &lt;typename T&gt;
inline void chmin(T &amp;lhs, T rhs) {
  lhs = min(lhs, rhs);
}

template &lt;typename T, typename U&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const pair&lt;T, U&gt; &amp;p) {
  os &lt;&lt; "(" &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ")";
  return os;
}

template &lt;typename T&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;v) {
  os &lt;&lt; "[";
  forn(i, sz(v)) {
    if (i &gt; 0) os &lt;&lt; ", ";
    os &lt;&lt; v[i];
  }
  os &lt;&lt; "]";
  return os;
}

template &lt;typename T, size_t N&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const array&lt;T, N&gt; &amp;v) {
  os &lt;&lt; "[";
  forn(i, N) {
    if (i &gt; 0) os &lt;&lt; ", ";
    os &lt;&lt; v[i];
  }
  os &lt;&lt; "]";
  return os;
}

int main(){
    fastIO();
    //aca empieza el problema
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cómo-practicar"><a class="header" href="#cómo-practicar">Cómo practicar</a></h1>
<p>Practicar no es trivial, ya que depende de la resiliencia, conocimiento y motivación del estudiante. A continuación, enlazamos algunos recursos útiles sobre este tema:</p>
<ul>
<li><a href="https://codeforces.com/blog/entry/91114">My opinion on how to practice competitive programming - Radewoosh</a></li>
<li><a href="https://codeforces.com/blog/entry/98806">How to practice Competitive Programming - Um_nik</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="problemas-introductorios"><a class="header" href="#problemas-introductorios">Problemas Introductorios</a></h1>
<p>Para familiarizarse con la programación competitiva, se sugieren los siguientes problemas introductorios:</p>
<ul>
<li><a href="https://cses.fi/problemset/task/1617">Bit Strings</a></li>
<li><a href="https://cses.fi/problemset/task/1754">Coin Piles</a></li>
<li><a href="https://cses.fi/problemset/task/2165">Tower of Hanoi</a></li>
<li><a href="https://cses.fi/problemset/task/2165">Number Spiral</a></li>
<li><a href="https://cses.fi/problemset/task/1625">Grid Paths</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matemáticas"><a class="header" href="#matemáticas">Matemáticas</a></h1>
<p>A diferencia de los otros temas que serán mencionados en la guía, los algoritmos de esta sección no entran dentro del temario de <em>Algoritmos y Estructuras de Datos</em>. Por eso, sugerimos que todos los miembros del equipo lean esta sección.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divisibilidad"><a class="header" href="#divisibilidad">Divisibilidad</a></h1>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<center><i>Los primos son legos</i></center>
<h2 id="primos"><a class="header" href="#primos">Primos</a></h2>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<p>Un entero positivo \(a\) es divisor o factor de un entero \(b\), si \(b\) es divisible por \(a\), lo que implica que existe un entero \(k\) tal que \(b = ka\). Un entero \(n &gt; 1\) es primo si sus únicos divisores son \(1\) y \(n\). Los enteros mayores que \(1\) y que no son primos son llamados compuestos.</p>
<p>Cualquier entero positivo tiene una única factorización prima, una forma de descomponerlo como una multiplicación de primos, de la siguiente forma</p>
<p>$$n = {p_1}^{a_1} {p_2}^{a_2} \cdots {p_k}^{a_k}$$</p>
<p>Donde \(p_i\) son primos diferentes y las \(a_i\) son enteros positivos.</p>
<h3 id="algoritmo-factorización-de-primos-singular"><a class="header" href="#algoritmo-factorización-de-primos-singular"><strong>Algoritmo:</strong> Factorización de Primos (singular)</a></h3>
<pre><code class="language-cpp">vi factor(tint n) {
    vi ret;
    forsn(i, 2, sqrt(n)+1) 
    {
        while (n % i == 0) 
        {
            ret.push_back(i);
            n /= i;
        }
    }
    if (n &gt; 1)
        ret.push_back(n);
    return ret;
}
</code></pre>
<ul>
<li>Memoria: \( \Theta(1) \)</li>
<li>Complejidad \( \Theta(\sqrt{n}) \)</li>
</ul>
<p>Este algoritmo tiene complejidad \(\Theta(\sqrt{n})\), ya que iteramos por los factores \(i \leq \sqrt{n}\). Podría resultar confuso que quede está complejidad, siendo que tenemos un while adentro del for, pero como este se encarga de dividir a \(n\), está acelerando el código.</p>
<h3 id="algoritmo-criba-de-eratóstenes"><a class="header" href="#algoritmo-criba-de-eratóstenes"><strong>Algoritmo:</strong> Criba de Eratóstenes</a></h3>
<p>Ahora sabemos cómo encontrar la descomposición en primos de un número. Pero ¿cómo hacemos para encontrar a todos los primos menores a un número arbitrario \(n\)? podríamos implementar una función <strong>es_primo(n)</strong> que funcione en \(\Theta(\sqrt{n})\) y simplemente iterar por los números entre 1 y \(n\), llamando a esta función por cada numero. La complejidad seria \(\Theta(n \sqrt{n})\). Resulta que podemos resolver este problema en tan solo \(\Theta (n\log(n))\).</p>
<pre><code class="language-cpp">tint n;
vector&lt;bool&gt; is_prime(n+1, 1);
is_prime[0] = is_prime[1] = false;
forsn(i, 2, n+1) 
    if (is_prime[i])// si i es primo
        for (tint j = i * 2; j &lt;= n; j += i)
            is_prime[j] = false; //pinto a todos los a * i como compuestos
</code></pre>
<ul>
<li>Memoria: \( \Theta(1) \)</li>
<li>Complejidad \( \Theta(\n \log{n}) \)</li>
</ul>
<p>La magia está en la serie armónica:</p>
<blockquote>
<p><strong>Serie armónica</strong> \(\sum_{i = 0}^{n}\frac{1}{i} = H_n \sim \Theta(\log(n))\)</p>
</blockquote>
<p>A lo sumo iteramos \(\frac{n}{i}\) veces por cada número (el número es menor ya que no iteramos por los compuestos). Entonces queda claro que la complejidad está acotada por \(\mathcal{O}(n\log n)\).</p>
<h3 id="algoritmo-factorización-de-primos-plural"><a class="header" href="#algoritmo-factorización-de-primos-plural"><strong>Algoritmo:</strong> Factorización de Primos (plural)</a></h3>
<p>El algoritmo de factorización singular mencionado anteriormente es óptimo para encontrar la factorización de un número en particular, pero ¿qué pasa si necesitamos saber la factorización de \(n\) números?. Resulta tentador responder que podemos usar el algoritmo \(n\) veces, y es verdad... pero no es óptimo. Si hiciéramos esto nos quedaría un código con complejidad \(\Theta(n\sqrt{M})\), donde M es el máximo valor que puede tomar alguno de nuestros números. Esta complejidad no es muy buena. ¿Cómo podemos usar la <strong>criba de Eratóstenes</strong> para mejorar la complejidad?</p>
<details>
  <summary>Pista </summary>
<p>Asumamos que tenemos precomputados los primos del 1 al \(n\), podemos mejorar nuestro algoritmo de factorización?</p>
</details>
<details>
  <summary>Respuesta a la pista </summary>
<p>En vez de iterar por todos los enteros menores a \(\sqrt{n}\), podemos iterar por todos los primos menores a \(\sqrt{n}\).</p>
</details>
<pre><code class="language-cpp">vi factor(tint n) {
    vi ret;
    for(auto &amp;i:primos) 
    {
        if(i * i &gt; n)// me pase de largo
            break;
        while (n % i == 0) 
        {
            ret.push_back(i);
            n /= i;
        }
    }
    if (n &gt; 1)
        ret.push_back(n);
    return ret;
}
</code></pre>
<ul>
<li>Memoria: \(\Theta(1)\)</li>
<li>Complejidad: \(\Theta(log(n))\)</li>
</ul>
<p>Si repetimos este proceso para los \(n\) números, nos queda \( \Theta(n\log n)\) de preprocesamiento (criba) y \( \Theta(n\log n)\) de factorizar a todos los números, buenísimo.</p>
<h3 id="cantidad-de-divisores"><a class="header" href="#cantidad-de-divisores">Cantidad de divisores</a></h3>
<blockquote>
<p>Importancia: <font color="yellow">Media</font></p>
</blockquote>
<p>Sabemos que
$$n = {p_1}^{a_1} {p_2}^{a_2} \cdots {p_k}^{a_k}$$</p>
<p>Ahora vemos que cada divisor \(d\) de un numero \(n\) puede ser pensado como un subconjunto de los primos que lo componen. Por ejemplo, 6 y 4 son divisores de 12 ya que:
$$12 = 2^2 \cdot 3^1 $$
$$6 = 2^1 \cdot 3^1$$
$$4 = 2^2$$</p>
<p>Cada divisor, entonces, puede ser expresado con un conjunto de exponentes asociados a los primos de la descomposición de \(n\).</p>
<p>$$12 = \text{{2, 1}}$$
$$6 = \text{{1, 1}}$$
$$4 = \text{{2, 0}}$$</p>
<p>De esto sale que la contar la cantidad de divisores equivale a contar la cantidad de representaciones de este tipo. Cada posición puede tomar un valor en el rango \([0, a_i]\). Por lo tanto, la cantidad de divisores es</p>
<p>$$\prod_{i = 1}^{\text{k}} (a_i + 1) $$</p>
<h2 id="gcd-y-lcm"><a class="header" href="#gcd-y-lcm">GCD y LCM</a></h2>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<p>En varias ocasiones es útil recordar las operaciones de <strong>GCD</strong> y <strong>LCM</strong> cuando trabajamos con enteros. Por ahora simplemente se dan las definiciones:</p>
<ul>
<li><strong>gcd(a, b)</strong>: <em>Greatest Common Divisor</em>, el entero mas grande que divide tanto a \(a\) como a \(b\). Si <strong>gcd(a, b) == 1</strong> se dice <em>"a y b son coprimos"</em>.</li>
<li><strong>lcm(a, b) = a*b/gcd(a, b)</strong></li>
</ul>
<blockquote>
<p>Nota: a partir de C++17 <strong>gcd</strong> es una operación incluida en la librería estándar, es decir, se puede hacer <strong>gcd(a, b)</strong> sin necesidad de incluir código extra.</p>
</blockquote>
<h2 id="phi-de-euler"><a class="header" href="#phi-de-euler">Phi de Euler</a></h2>
<blockquote>
<p>Importancia: <font color="red">Baja</font></p>
</blockquote>
<p>próximamente</p>
<h2 id="problemas"><a class="header" href="#problemas">Problemas</a></h2>
<ul>
<li><a href="https://cses.fi/problemset/task/1713">Counting Divisors</a></li>
<li><a href="https://cses.fi/problemset/task/1081">Common Divisors</a></li>
<li><a href="https://cses.fi/problemset/task/1082">Sum of Divisors</a></li>
<li><a href="https://cses.fi/problemset/task/2182">Divisor Analysis</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aritmética-modular"><a class="header" href="#aritmética-modular">Aritmética Modular</a></h1>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<center>
<i>Los números no, sus restos.</i>
</center>
<p>En muchas situaciones, la solución a un problema requiere lidiar con números de magnitudes inmensas (\(&gt;10^{18}\)), lo que causa ciertas incomodidades cuando tenemos que operar con ellos. Una solución común a esta problemática es pedir el resultado módulo un número primo grande. En esta sección vemos operaciones básicas de la aritmética modular.</p>
<h2 id="repaso-de-operaciones-básicas"><a class="header" href="#repaso-de-operaciones-básicas">Repaso de operaciones básicas</a></h2>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<p>$$(a+b) \bmod m = (a \bmod m + b \bmod m) \bmod m$$</p>
<p>$$(a-b) \bmod m = (a \bmod m - b \bmod m) \bmod m$$</p>
<p>$$(a \cdot b) \pmod{m} = ((a \bmod m) \cdot (b \bmod m)) \bmod m$$</p>
<p>$$a^b \bmod {m} = (a \bmod m)^b \bmod m$$</p>
<h2 id="exponenciación-rápida-y-modular"><a class="header" href="#exponenciación-rápida-y-modular">Exponenciación Rápida (y modular)</a></h2>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<p>Se muestra cómo exponenciar en \(\Theta(log(n))\). Como detalle, se añade que sea modular, pero esto es opcional.</p>
<h3 id="algoritmo-modpow-exponenciación-rápida"><a class="header" href="#algoritmo-modpow-exponenciación-rápida"><strong>Algoritmo:</strong> modPow (Exponenciación Rápida)</a></h3>
<pre><code class="language-cpp">tint modPow(tint x, tint n, const tint MOD)
{
    if (n == 0)
        return 1;
    tint ans = modPow(x, n / 2, MOD);
    ans = (ans * ans) % MOD;
    if (n % 2)
        ans = (ans * x) % MOD;
    return ans;
}
</code></pre>
<ul>
<li>Memoria: \( \Theta(1) \)</li>
<li>Complejidad \( \Theta(\log{n}) \)</li>
</ul>
<h2 id="inversa-modular"><a class="header" href="#inversa-modular">Inversa Modular</a></h2>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<center>
<i>Dividir no es tan fácil en la aritmética modular</i>
</center>
<h3 id="pequeño-teorema-de-fermat-fermatito"><a class="header" href="#pequeño-teorema-de-fermat-fermatito">Pequeño Teorema de Fermat (Fermatito)</a></h3>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<p>Resulta que si el módulo es primo, podemos usar un famoso teorema de la teoría de números llamada "Pequeño teorema de Fermat", a veces cariñosamente referido como "Fermatito":</p>
<p>$$
a^{p-1}\equiv 1  \text{  (mod p)} \text{, con p primo}
$$</p>
<p>Separando el producto, nos queda</p>
<p>$$
a^{p-2}a\equiv 1  \text{  (mod p)}
$$</p>
<p>Con lo que podemos ver que \(a^{p-2}\) es la inversa modular de a. Por lo tanto, si necesitamos dividir por a, simplemente podemos multiplicar por \(a^{-1} \equiv a^{p-2}\)</p>
<h3 id="algoritmo-inversa-modular"><a class="header" href="#algoritmo-inversa-modular"><strong>Algoritmo:</strong> Inversa modular</a></h3>
<pre><code class="language-cpp">tint modInv(tint num, const tint MOD){
    return modPow(num, MOD-2, MOD); // usamos la funcion de exponenciacion modular definida anteriormente.
}
</code></pre>
<ul>
<li>Memoria: \( \Theta(1) \)</li>
<li>Complejidad \( \Theta(\log{n}) \)</li>
</ul>
<h4 id="ejemplo"><a class="header" href="#ejemplo">Ejemplo</a></h4>
<pre><code class="language-cpp">tint num = 19; // número cualquiera, módulo MOD
tint numDivididoPor2 = (num * modInv(2, MOD)) % MOD;
</code></pre>
<h2 id="problemas-1"><a class="header" href="#problemas-1">Problemas</a></h2>
<ul>
<li><a href="https://cses.fi/problemset/task/1095">Exponentiation I</a></li>
<li><a href="https://cses.fi/problemset/task/1712">Exponentiation II</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinatoria"><a class="header" href="#combinatoria">Combinatoria</a></h1>
<blockquote>
<p>Importancia: <font color="yellow">Media</font></p>
</blockquote>
<center>
<i>Contar cosas puede ser difícil</i>
</center>
<p>Es común que en un problema se nos pregunte <em>"¿De cuántas formas podemos hacer X?"</em> o <em>"¿De cuántas formas podemos ganar un determinado juego desde una posición inicial?"</em>. Para este tipo de problemas, necesitamos recurrir a la combinatoria.</p>
<h2 id="coeficiente-binomial"><a class="header" href="#coeficiente-binomial">Coeficiente Binomial</a></h2>
<blockquote>
<p>Importancia: <font color="green">Alta</font></p>
</blockquote>
<p>Si cursaron probabilidad, están familiarizados con el coeficiente binomial: la forma de contar cuántas formas existen para elegir \(k\) elementos de un conjunto de \(n\) elementos posibles. Disponemos de una fórmula cerrada para calcularlo:</p>
<p>$$
{n \choose k} = \frac{n!}{(n-k)!k!}
$$</p>
<p>El problema con esta fórmula es que necesitamos conocer los valores de \(n!\), \((n-k)!\) y \(k!\) para calcularla explícitamente. El inconveniente es que los números factoriales aumentan en valor absoluto de manera muy rápida. Por ejemplo, \(100 \choose 4\) es \(3, 921, 225, \) pero si quisiéramos calcularlo con la fórmula que conocemos, necesitaríamos primero calcular \(100! = 9.33 \times 10^{157}\), lo que es aproximadamente dos veces mayor que la cantidad de átomos en el universo conocido. Es decir, para la mayoría de nuestros usos, los números que queremos calcular son razonablemente pequeños, pero los factoriales necesarios son extremadamente grandes.</p>
<h3 id="triángulo-de-pascal"><a class="header" href="#triángulo-de-pascal">Triángulo de Pascal</a></h3>
<p>La solución es la siguiente recurrencia:
$$\binom{n}{k} = \binom{n - 1}{k - 1} + \binom{n - 1}{k}$$</p>
<p>Los casos base de la recurrencia son:</p>
<p>$$\binom{n}{0} = \binom{n}{n} = 1$$</p>
<p>Siendo que existe una única forma de elegir un conjunto de 0 elementos, o uno que incluya a todos.</p>
<p>Esta fórmula recursiva es conocida como el <strong>Triángulo de Pascal</strong>.</p>
<pre><code class="language-cpp">tint binomial(tint n, tint k)
{

    // dp[i][j] guarda iCj
    vector&lt;vi&gt; dp(n + 1, vector&lt;tint&gt;(k + 1, 0));

    // casos base descritos arriba
    forn(i, n + 1)
    {
        dp[i][0] = 1;
        if (i &lt;= k)
            dp[i][i] = 1;
    }

    forn(i, n + 1)
        forsn(j, 1, min(i, k) + 1)
            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]); // usa la recurrencia de arriba

    return dp[n][k];

}
</code></pre>
<h2 id="subfactorial"><a class="header" href="#subfactorial">Subfactorial</a></h2>
<blockquote>
<p>Importancia: <font color="red">Baja</font></p>
</blockquote>
<p>próximamente.</p>
<h2 id="números-de-catalán"><a class="header" href="#números-de-catalán">Números de Catalán</a></h2>
<blockquote>
<p>Importancia: <font color="red">Baja</font></p>
</blockquote>
<p>próximamente.</p>
<h2 id="problemas-2"><a class="header" href="#problemas-2">Problemas</a></h2>
<ul>
<li><a href="https://cses.fi/problemset/task/1079">Binomial Coefficients</a></li>
<li><a href="https://cses.fi/problemset/task/1715">Creating Strings</a></li>
<li><a href="https://cses.fi/problemset/task/1716">Distributing Apples</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
